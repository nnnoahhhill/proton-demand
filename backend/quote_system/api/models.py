# api/models.py

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional, Union
import uuid

from ..core.common_types import (
    ProcessType, Print3DTechnology, AnalysisResult as CoreAnalysisResult,
    DFMIssue as CoreDFMIssue, DFMLevel
)

# --- Request Models ---

class AnalysisRequest(BaseModel):
    """Request model for initiating an analysis."""
    file_url: str = Field(..., description="URL accessible by the server to download the CAD file.")
    process_type: ProcessType = Field(..., description="The manufacturing process to analyze for (e.g., PRINT_3D).")
    technology: str = Field(..., description="The specific technology within the process (e.g., FDM, SLA for PRINT_3D).")
    material_name: str = Field(..., description="The name of the material to use (e.g., PLA, ABS). Must match available materials for the process.")
    # Optional configuration overrides can be added here
    # config_overrides: Optional[Dict[str, Any]] = None

    class Config:
        use_enum_values = True # Allow sending enum names (e.g., "PRINT_3D")

# --- Response Models ---

class DFMIssue(BaseModel):
    """API representation of a DFM issue."""
    issue_type: str # Name of the DFMIssueType enum member
    level: DFMLevel # Use the enum directly for clarity (CRITICAL, ERROR, WARN, INFO)
    message: str
    recommendation: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    # visualization_hint could be added if needed for frontend rendering

    @classmethod
    def from_core(cls, core_issue: CoreDFMIssue) -> 'DFMIssue':
        return cls(
            issue_type=core_issue.issue_type.name, # Get enum member name
            level=core_issue.level,
            message=core_issue.message,
            recommendation=core_issue.recommendation,
            details=core_issue.details
            # visualization_hint=core_issue.visualization_hint
        )

class AnalysisResponse(BaseModel):
    """Response model containing the analysis results."""
    analysis_id: uuid.UUID = Field(default_factory=uuid.uuid4, description="Unique ID for this analysis task.")
    success: bool
    message: str
    process_type: str # Name of the ProcessType enum member
    results: Dict[str, Any] # Contains process-specific results (properties, slicing, etc.)
    dfm_issues: List[DFMIssue]
    input_parameters: Dict[str, Any] # Echo back the input params for context
    execution_time_ms: Optional[int] = None

    @classmethod
    def from_core(cls, core_result: CoreAnalysisResult) -> 'AnalysisResponse':
        return cls(
            success=core_result.success,
            message=core_result.message,
            process_type=core_result.process_type.name, # Get enum member name
            results=core_result.results,
            dfm_issues=[DFMIssue.from_core(issue) for issue in core_result.dfm_issues],
            input_parameters=core_result.input_parameters,
            execution_time_ms=core_result.execution_time_ms
            # analysis_id will be generated by default_factory
        )

class ErrorDetail(BaseModel):
    loc: Optional[List[str]] = None
    msg: str
    type: Optional[str] = None

class ErrorResponse(BaseModel):
    """Standard error response model."""
    detail: Union[str, List[ErrorDetail]]

# Example usage for generating schema:
# if __name__ == "__main__":
#     import json
#     print(json.dumps(AnalysisRequest.schema(), indent=2))
#     print(json.dumps(AnalysisResponse.schema(), indent=2))
#     print(json.dumps(ErrorResponse.schema(), indent=2)) 